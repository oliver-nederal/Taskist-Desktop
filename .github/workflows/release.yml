name: Release

on:
  push:
    # STRICTLY triggers only on v* tags. 
    # Do NOT add "branches: [main]" here or it will run on every commit.
    tags:
      - "v*"
  workflow_dispatch:
    inputs:
      version:
        description: "Version to release (e.g. 0.1.0)"
        required: true
        type: string

permissions:
  contents: write

jobs:
  create-release:
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.get-version.outputs.version }}
      release_id: ${{ steps.create-release.outputs.result }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get version
        id: get-version
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            VERSION="${{ inputs.version }}"
          else
            VERSION="${GITHUB_REF#refs/tags/v}"
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: Create or Reuse Release
        id: create-release
        uses: actions/github-script@v7
        with:
          script: |
            const tag = `v${{ steps.get-version.outputs.version }}`;
            const { owner, repo } = context.repo;

            try {
              // Check if release exists
              const { data: release } = await github.rest.repos.getReleaseByTag({ owner, repo, tag });
              console.log(`Found existing release: ${release.html_url}`);
              return release.id;
            } catch (e) {
              if (e.status === 404) {
                // Create new draft release
                const { data: release } = await github.rest.repos.createRelease({
                  owner, repo,
                  tag_name: tag,
                  name: `Taskly ${tag}`,
                  body: "Release notes will be updated automatically.",
                  draft: true,
                  prerelease: false
                });
                console.log(`Created release: ${release.html_url}`);
                return release.id;
              }
              throw e;
            }

  build-tauri:
    needs: create-release
    # This prevents the job from running until the release exists
    permissions:
      contents: write
    strategy:
      fail-fast: false
      matrix:
        include:
          - platform: windows-latest
            args: ""
          - platform: macos-latest
            args: "--target universal-apple-darwin"
            
    runs-on: ${{ matrix.platform }}
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.platform == 'macos-latest' && 'aarch64-apple-darwin,x86_64-apple-darwin' || '' }}

      - name: Install frontend deps
        run: npm install

      - name: Verify signing keys are present
        shell: bash
        run: |
          if [ -z "${{ secrets.TAURI_PRIVATE_KEY }}" ]; then
            echo "ERROR: TAURI_PRIVATE_KEY secret is not set!"
            exit 1
          fi
          if [ -z "${{ secrets.TAURI_KEY_PASSWORD }}" ]; then
            echo "ERROR: TAURI_KEY_PASSWORD secret is not set!"
            exit 1
          fi
          echo "Signing keys are configured âœ“"

      - name: Build and Upload Assets
        uses: tauri-apps/tauri-action@v0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_KEY_PASSWORD }}
        with:
          tagName: v${{ needs.create-release.outputs.version }}
          releaseId: ${{ needs.create-release.outputs.release_id }}
          args: ${{ matrix.args }}
          includeUpdaterJson: false

  generate-update-manifest:
    # CRITICAL: This waits for build-tauri to finish uploading .sig files
    needs: [create-release, build-tauri]
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Generate latest.json
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const { owner, repo } = context.repo;
            const version = "${{ needs.create-release.outputs.version }}";
            const tag = `v${version}`;

            // 1. Fetch the Release (now populated with assets)
            console.log(`Fetching release for ${tag}...`);
            const { data: release } = await github.rest.repos.getReleaseByTag({ owner, repo, tag });
            
            const signatures = {};
            const urls = {};
            
            // 2. Map Assets
            console.log('Available assets:', release.assets.map(a => a.name).join(', '));
            
            for (const asset of release.assets) {
              if (asset.name.endsWith('.sig')) {
                console.log(`Found signature file: ${asset.name}`);
                
                // Determine platform
                let platform = null;
                if (asset.name.includes('x64-setup.exe') || asset.name.includes('x64_en-US.msi')) {
                  platform = 'windows-x86_64';
                }
                // Tauri often puts universal mac builds in darwin-x86_64 for update compatibility
                else if (asset.name.includes('app.tar.gz')) {
                  platform = 'darwin-x86_64';
                }
                else if (asset.name.includes('AppImage.tar.gz')) {
                  platform = 'linux-x86_64';
                }

                if (platform) {
                  console.log(`Processing signature for ${platform}: ${asset.name}`);
                  
                  // Download signature content safely
                  const response = await github.request(asset.browser_download_url);
                  const sigContent = Buffer.from(response.data).toString('utf-8');
                  signatures[platform] = sigContent.trim();
                  
                  // Find installer URL
                  const installerName = asset.name.replace('.sig', '');
                  const installer = release.assets.find(a => a.name === installerName);
                  if (installer) {
                    console.log(`Found installer for ${platform}: ${installer.name}`);
                    urls[platform] = installer.browser_download_url;
                  } else {
                    console.log(`WARNING: No installer found for signature ${asset.name}`);
                  }
                } else {
                  console.log(`Skipping unknown signature format: ${asset.name}`);
                }
              }
            }

            // 3. Create Manifest
            const manifest = {
              version: version,
              notes: release.body,
              pub_date: new Date().toISOString(),
              platforms: {}
            };

            for (const [plat, sig] of Object.entries(signatures)) {
              if (urls[plat]) {
                manifest.platforms[plat] = { signature: sig, url: urls[plat] };
              }
            }
            
            console.log("Final manifest:", JSON.stringify(manifest, null, 2));
            
            if (Object.keys(manifest.platforms).length === 0) {
              console.error("WARNING: No platforms found! This likely means .sig files are missing from the release.");
              console.error("Make sure TAURI_PRIVATE_KEY and TAURI_KEY_PASSWORD secrets are configured.");
            }

            // 4. Upload latest.json
            
            // Check for existing latest.json and delete it to avoid collision
            const existingJson = release.assets.find(a => a.name === 'latest.json');
            if (existingJson) {
              await github.rest.repos.deleteReleaseAsset({ owner, repo, asset_id: existingJson.id });
            }

            await github.rest.repos.uploadReleaseAsset({
              owner, repo,
              release_id: release.id,
              name: 'latest.json',
              data: JSON.stringify(manifest, null, 2)
            });

            // 5. Publish Release
            await github.rest.repos.updateRelease({
              owner, repo,
              release_id: release.id,
              draft: false
            });